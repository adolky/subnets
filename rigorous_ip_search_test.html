<!DOCTYPE html>
<html>
<head>
    <title>Rigorous IP Search Test Suite</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .test-section { margin: 20px 0; padding: 20px; border: 1px solid #e0e0e0; border-radius: 8px; background: #fafafa; }
        .test-case { margin: 15px 0; padding: 15px; background: white; border-left: 4px solid #2196F3; border-radius: 4px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 4px; font-weight: bold; }
        .success { background: #e8f5e8; color: #2e7d32; border-left: 4px solid #4caf50; }
        .error { background: #ffebee; color: #c62828; border-left: 4px solid #f44336; }
        .warning { background: #fff3e0; color: #ef6c00; border-left: 4px solid #ff9800; }
        .info { background: #e3f2fd; color: #1565c0; border-left: 4px solid #2196f3; }
        .code { font-family: 'Courier New', monospace; background: #f8f8f8; padding: 8px; border-radius: 4px; border: 1px solid #ddd; }
        .debug-output { background: #263238; color: #fff; padding: 15px; border-radius: 4px; font-family: monospace; margin: 10px 0; overflow-x: auto; }
        .fix-suggestion { background: #f1f8e9; border: 1px solid #8bc34a; padding: 15px; border-radius: 4px; margin: 10px 0; }
        .network-info { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0; }
        .network-box { background: #e8eaf6; padding: 15px; border-radius: 4px; border: 1px solid #c5cae9; }
        button { background: #2196f3; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #1976d2; }
        .run-button { background: #4caf50; }
        .run-button:hover { background: #388e3c; }
        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
        th, td { padding: 8px 12px; text-align: left; border: 1px solid #ddd; }
        th { background: #f5f5f5; font-weight: bold; }
        .highlight-row { background-color: #fffacd !important; border: 2px solid #4CAF50 !important; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Rigorous IP Address Search Test Suite</h1>
            <p>Comprehensive testing and debugging for subnet IP search functionality</p>
        </div>

        <div class="test-section">
            <h3>üîç Test Configuration</h3>
            <p><strong>Base Network:</strong> 192.168.3.0/24 (as shown in screenshot)</p>
            <div class="network-info">
                <div class="network-box">
                    <h4>Expected Subnets:</h4>
                    <ul>
                        <li>192.168.3.0/25 (192.168.3.0 - 192.168.3.127)</li>
                        <li>192.168.3.128/26 (192.168.3.128 - 192.168.3.191)</li>
                        <li>192.168.3.192/26 (192.168.3.192 - 192.168.3.255)</li>
                    </ul>
                </div>
                <div class="network-box">
                    <h4>Problem IP:</h4>
                    <p><strong>192.168.3.4</strong> should be found in <strong>192.168.3.0/25</strong></p>
                    <p>Range: 192.168.3.0 - 192.168.3.127</p>
                    <p>Currently shows: "not found"</p>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>‚ö° Quick Test Runner</h3>
            <button class="run-button" onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="debugTableParsing()">üîç Debug Table Parsing</button>
            <button onclick="testIPMath()">üßÆ Test IP Mathematics</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>

        <div id="testResults"></div>

        <!-- Mock subnet table for testing -->
        <div class="test-section" style="display: none;">
            <table id="mockSubnetTable">
                <thead>
                    <tr>
                        <th>Subnet address</th>
                        <th>Range of addresses</th>
                        <th>Useable IPs</th>
                        <th>Hosts</th>
                        <th>VLAN Name</th>
                        <th>Divide</th>
                        <th>Join</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>192.168.3.0/25</td>
                        <td>192.168.3.0 - 192.168.3.127</td>
                        <td>192.168.3.1 - 192.168.3.126</td>
                        <td>126</td>
                        <td><input type="text" placeholder="VLAN Name"></td>
                        <td><a href="#">Divide</a></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>192.168.3.128/26</td>
                        <td>192.168.3.128 - 192.168.3.191</td>
                        <td>192.168.3.129 - 192.168.3.190</td>
                        <td>62</td>
                        <td><input type="text" placeholder="VLAN Name"></td>
                        <td><a href="#">Divide</a></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>192.168.3.192/26</td>
                        <td>192.168.3.192 - 192.168.3.255</td>
                        <td>192.168.3.193 - 192.168.3.254</td>
                        <td>62</td>
                        <td><input type="text" placeholder="VLAN Name"></td>
                        <td><a href="#">Divide</a></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Copy the functions from the main application for testing
        
        function isValidIPAddress(ip) {
            const pattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
            const match = ip.match(pattern);
            
            if (!match) return false;
            
            for (let i = 1; i <= 4; i++) {
                const octet = parseInt(match[i]);
                if (octet < 0 || octet > 255) {
                    return false;
                }
            }
            
            return true;
        }

        function ipToLong(ip) {
            const parts = ip.split('.');
            return (parseInt(parts[0]) << 24 | parseInt(parts[1]) << 16 | parseInt(parts[2]) << 8 | parseInt(parts[3])) >>> 0;
        }

        function isIPInSubnet(targetIP, networkIP, maskBits) {
            const targetLong = ipToLong(targetIP);
            const networkLong = ipToLong(networkIP);
            const subnetMask = (-1 << (32 - maskBits)) >>> 0;
            
            const networkAddress = networkLong & subnetMask;
            const broadcastAddress = networkAddress | (~subnetMask >>> 0);
            
            return targetLong >= networkAddress && targetLong <= broadcastAddress;
        }

        // Current implementation (potentially buggy)
        function findSubnetForIP_Current(targetIP) {
            const table = document.getElementById('mockSubnetTable');
            if (!table) return null;
            
            const rows = table.getElementsByTagName('tr');
            
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                if (cells.length === 0) continue;
                
                for (let j = 0; j < cells.length; j++) {
                    if (cells[j].style.display !== 'none') {
                        const cellText = cells[j].textContent.trim();
                        
                        if (cellText.includes('/')) {
                            const cidrMatch = cellText.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/(\d{1,2})/);
                            if (cidrMatch) {
                                const networkIP = cidrMatch[1];
                                const maskBits = parseInt(cidrMatch[2]);
                                
                                if (isIPInSubnet(targetIP, networkIP, maskBits)) {
                                    return {
                                        network: networkIP,
                                        mask: maskBits,
                                        rowId: i,
                                        cellText: cellText
                                    };
                                }
                            }
                        }
                        break;
                    }
                }
            }
            
            return null;
        }

        // Fixed implementation
        function findSubnetForIP_Fixed(targetIP) {
            const table = document.getElementById('mockSubnetTable');
            if (!table) return null;
            
            const rows = table.getElementsByTagName('tr');
            
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                if (cells.length === 0) continue;
                
                // Check the first cell (subnet address column)
                const subnetCell = cells[0];
                if (!subnetCell) continue;
                
                const cellText = subnetCell.textContent.trim();
                
                // Look for CIDR notation
                const cidrMatch = cellText.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/(\d{1,2})/);
                if (cidrMatch) {
                    const networkIP = cidrMatch[1];
                    const maskBits = parseInt(cidrMatch[2]);
                    
                    if (isIPInSubnet(targetIP, networkIP, maskBits)) {
                        return {
                            network: networkIP,
                            mask: maskBits,
                            rowId: i,
                            cellText: cellText,
                            method: 'CIDR_NOTATION'
                        };
                    }
                }
            }
            
            return null;
        }

        function runAllTests() {
            const results = document.getElementById('testResults');
            results.innerHTML = '<h3>üß™ Test Results</h3>';
            
            const testCases = [
                // Critical test cases
                { ip: '192.168.3.4', description: 'Problem IP from screenshot', expected: '192.168.3.0/25' },
                { ip: '192.168.3.1', description: 'First usable IP in subnet', expected: '192.168.3.0/25' },
                { ip: '192.168.3.126', description: 'Last usable IP in subnet', expected: '192.168.3.0/25' },
                { ip: '192.168.3.127', description: 'Broadcast address', expected: '192.168.3.0/25' },
                { ip: '192.168.3.128', description: 'Second subnet start', expected: '192.168.3.128/26' },
                { ip: '192.168.3.150', description: 'Middle of second subnet', expected: '192.168.3.128/26' },
                { ip: '192.168.3.191', description: 'Second subnet end', expected: '192.168.3.128/26' },
                { ip: '192.168.3.200', description: 'Third subnet', expected: '192.168.3.192/26' },
                
                // Edge cases
                { ip: '192.168.2.255', description: 'IP outside range (low)', expected: null },
                { ip: '192.168.4.1', description: 'IP outside range (high)', expected: null },
                { ip: '10.0.0.1', description: 'Completely different network', expected: null },
                { ip: '999.999.999.999', description: 'Invalid IP format', expected: 'INVALID' },
                { ip: '192.168.3.256', description: 'Invalid octet', expected: 'INVALID' },
                { ip: '', description: 'Empty string', expected: 'INVALID' }
            ];

            let passed = 0;
            let failed = 0;

            testCases.forEach((testCase, index) => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'test-case';
                
                let status, message, actualResult;
                
                // Validate IP first
                if (testCase.expected === 'INVALID') {
                    if (!isValidIPAddress(testCase.ip)) {
                        status = 'success';
                        message = `‚úÖ Correctly identified invalid IP: "${testCase.ip}"`;
                        passed++;
                    } else {
                        status = 'error';
                        message = `‚ùå Should reject invalid IP: "${testCase.ip}"`;
                        failed++;
                    }
                } else if (!isValidIPAddress(testCase.ip)) {
                    status = 'error';
                    message = `‚ùå Valid IP "${testCase.ip}" incorrectly marked as invalid`;
                    failed++;
                } else {
                    // Test both implementations
                    const currentResult = findSubnetForIP_Current(testCase.ip);
                    const fixedResult = findSubnetForIP_Fixed(testCase.ip);
                    
                    const currentMatch = currentResult ? `${currentResult.network}/${currentResult.mask}` : null;
                    const fixedMatch = fixedResult ? `${fixedResult.network}/${fixedResult.mask}` : null;
                    
                    if (fixedMatch === testCase.expected) {
                        status = 'success';
                        message = `‚úÖ ${testCase.description}: "${testCase.ip}" ‚Üí ${fixedMatch || 'not found'}`;
                        if (currentMatch !== fixedMatch) {
                            message += `<br>&nbsp;&nbsp;&nbsp;&nbsp;üìä Current: ${currentMatch || 'not found'} | Fixed: ${fixedMatch || 'not found'}`;
                        }
                        passed++;
                    } else {
                        status = 'error';
                        message = `‚ùå ${testCase.description}: "${testCase.ip}"<br>&nbsp;&nbsp;&nbsp;&nbsp;Expected: ${testCase.expected || 'not found'}<br>&nbsp;&nbsp;&nbsp;&nbsp;Current: ${currentMatch || 'not found'}<br>&nbsp;&nbsp;&nbsp;&nbsp;Fixed: ${fixedMatch || 'not found'}`;
                        failed++;
                    }
                }
                
                resultDiv.innerHTML = `
                    <strong>Test ${index + 1}:</strong> ${testCase.description}<br>
                    <strong>Input:</strong> <code>${testCase.ip}</code><br>
                    <div class="test-result ${status}">${message}</div>
                `;
                
                results.appendChild(resultDiv);
            });

            // Summary
            const summary = document.createElement('div');
            summary.className = `test-result ${failed === 0 ? 'success' : 'error'}`;
            summary.innerHTML = `
                <h4>üìä Test Summary</h4>
                <strong>Passed:</strong> ${passed}/${passed + failed} tests<br>
                <strong>Status:</strong> ${failed === 0 ? '‚úÖ All tests passed!' : `‚ùå ${failed} tests failed`}
            `;
            results.appendChild(summary);
        }

        function debugTableParsing() {
            const results = document.getElementById('testResults');
            results.innerHTML = '<h3>üîç Table Parsing Debug</h3>';
            
            const table = document.getElementById('mockSubnetTable');
            const rows = table.getElementsByTagName('tr');
            
            const debugDiv = document.createElement('div');
            debugDiv.innerHTML = '<h4>Table Structure Analysis:</h4>';
            
            for (let i = 1; i < rows.length; i++) {
                const cells = rows[i].getElementsByTagName('td');
                const rowDiv = document.createElement('div');
                rowDiv.className = 'debug-output';
                
                let rowContent = `Row ${i}:\n`;
                for (let j = 0; j < cells.length; j++) {
                    const cellText = cells[j].textContent.trim();
                    const display = cells[j].style.display || 'block';
                    rowContent += `  Cell ${j}: "${cellText}" (display: ${display})\n`;
                }
                
                // Test CIDR parsing
                const firstCell = cells[0].textContent.trim();
                const cidrMatch = firstCell.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/(\d{1,2})/);
                if (cidrMatch) {
                    rowContent += `  ‚úÖ CIDR Found: ${cidrMatch[1]}/${cidrMatch[2]}\n`;
                } else {
                    rowContent += `  ‚ùå No CIDR pattern found\n`;
                }
                
                rowDiv.textContent = rowContent;
                debugDiv.appendChild(rowDiv);
            }
            
            results.appendChild(debugDiv);
        }

        function testIPMath() {
            const results = document.getElementById('testResults');
            results.innerHTML = '<h3>üßÆ IP Mathematics Test</h3>';
            
            const testIP = '192.168.3.4';
            const subnet = '192.168.3.0';
            const mask = 25;
            
            const mathDiv = document.createElement('div');
            mathDiv.className = 'debug-output';
            
            const targetLong = ipToLong(testIP);
            const networkLong = ipToLong(subnet);
            const subnetMask = (-1 << (32 - mask)) >>> 0;
            const networkAddress = networkLong & subnetMask;
            const broadcastAddress = networkAddress | (~subnetMask >>> 0);
            
            mathDiv.textContent = `
IP Mathematics Verification:

Target IP: ${testIP}
  ‚Üí Long: ${targetLong} (0x${targetLong.toString(16)})

Network: ${subnet}/${mask}
  ‚Üí Network Long: ${networkLong} (0x${networkLong.toString(16)})
  ‚Üí Subnet Mask: ${subnetMask} (0x${subnetMask.toString(16)})
  ‚Üí Network Address: ${networkAddress} (0x${networkAddress.toString(16)})
  ‚Üí Broadcast Address: ${broadcastAddress} (0x${broadcastAddress.toString(16)})

Test: ${targetLong} >= ${networkAddress} && ${targetLong} <= ${broadcastAddress}
Result: ${targetLong >= networkAddress && targetLong <= broadcastAddress ? '‚úÖ IP is in subnet' : '‚ùå IP is NOT in subnet'}

Subnet Range: ${networkAddress} to ${broadcastAddress}
IP Position: ${targetLong} (within range: ${targetLong >= networkAddress && targetLong <= broadcastAddress})
            `;
            
            results.appendChild(mathDiv);
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
        }

        // Auto-run tests on load
        window.onload = function() {
            console.log('üß™ IP Search Test Suite Loaded');
            console.log('Run tests to identify and fix issues');
        };
    </script>
</body>
</html>